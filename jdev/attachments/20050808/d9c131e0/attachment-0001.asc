Only in src-plugins/sm: .deps
Common subdirectories: src-cvs/sm/CVS and src-plugins/sm/CVS
diff -u --ignore-space-change src-cvs/sm/Makefile.am src-plugins/sm/Makefile.am
--- src-cvs/sm/Makefile.am	2005-06-02 08:30:35.000000000 +0200
+++ src-plugins/sm/Makefile.am	2005-08-05 17:24:31.000000000 +0200
@@ -1,6 +1,26 @@
 INCLUDES = -DCONFIG_DIR=\"$(sysconfdir)\"
 
 bin_PROGRAMS = sm
+lib_LTLIBRARIES = libmod_active.la \
+                  libmod_announce.la \
+                  libmod_deliver.la \
+                  libmod_disco.la \
+                  libmod_disco-publish.la \
+                  libmod_echo.la \
+                  libmod_help.la \
+                  libmod_iq-last.la \
+                  libmod_iq-private.la \
+                  libmod_iq-time.la \
+                  libmod_iq-vcard.la \
+                  libmod_iq-version.la \
+                  libmod_offline.la \
+                  libmod_presence.la \
+                  libmod_privacy.la \
+                  libmod_roster.la \
+                  libmod_session.la \
+                  libmod_template-roster.la \
+                  libmod_vacation.la \
+                  libmod_validate.la
 
 noinst_HEADERS = sm.h
 sm_SOURCES = aci.c \
@@ -20,31 +40,71 @@
              storage_mysql.c \
              storage_pgsql.c \
 	     storage_oracle.c \
-             storage_sqlite.c \
-             mod_active.c \
-             mod_announce.c \
-             mod_deliver.c \
-             mod_disco.c \
-             mod_disco_publish.c \
-             mod_echo.c \
-             mod_help.c \
-             mod_offline.c \
-             mod_presence.c \
-             mod_privacy.c \
-             mod_roster.c \
-             mod_session.c \
-             mod_vacation.c \
-             mod_validate.c \
-             mod_iq_last.c \
-             mod_iq_private.c \
-             mod_iq_time.c \
-             mod_iq_vcard.c \
-             mod_iq_version.c \
-             mod_template_roster.c
-
+             storage_sqlite.c
+sm_LDFLAGS = -Wl,-export-dynamic
 sm_LDADD = $(top_builddir)/sx/libsx.la \
            $(top_builddir)/scod/libscod.la \
            $(top_builddir)/mio/libmio.la \
            $(top_builddir)/util/libutil.la \
            $(top_builddir)/subst/libsubst.la \
            $(top_builddir)/expat/libexpat.la
+
+libmod_active_la_SOURCES = mod_active.c
+libmod_active_la_LDFLAGS = -shared -E
+
+libmod_announce_la_SOURCES = mod_announce.c
+libmod_announce_la_LDFLAGS = -shared -E
+
+libmod_deliver_la_SOURCES = mod_deliver.c
+libmod_deliver_la_LDFLAGS = -shared -E
+
+libmod_disco_la_SOURCES = mod_disco.c
+libmod_disco_la_LDFLAGS = -shared -E
+
+libmod_disco_publish_la_SOURCES = mod_disco_publish.c
+libmod_disco_publish_la_LDFLAGS = -shared -E
+
+libmod_echo_la_SOURCES = mod_echo.c
+libmod_echo_la_LDFLAGS = -shared -E
+
+libmod_help_la_SOURCES = mod_help.c
+libmod_help_la_LDFLAGS = -shared -E
+
+libmod_iq_last_la_SOURCES = mod_iq_last.c
+libmod_iq_last_la_LDFLAGS = -shared -E
+
+libmod_iq_private_la_SOURCES = mod_iq_private.c
+libmod_iq_private_la_LDFLAGS = -shared -E
+
+libmod_iq_time_la_SOURCES = mod_iq_time.c
+libmod_iq_time_la_LDFLAGS = -shared -E
+
+libmod_iq_vcard_la_SOURCES = mod_iq_vcard.c
+libmod_iq_vcard_la_LDFLAGS = -shared -E
+
+libmod_iq_version_la_SOURCES = mod_iq_version.c
+libmod_iq_version_la_LDFLAGS = -shared -E
+
+libmod_offline_la_SOURCES = mod_offline.c
+libmod_offline_la_LDFLAGS = -shared -E
+
+libmod_presence_la_SOURCES = mod_presence.c
+libmod_presence_la_LDFLAGS = -shared -E
+
+libmod_privacy_la_SOURCES = mod_privacy.c
+libmod_privacy_la_LDFLAGS = -shared -E
+
+libmod_roster_la_SOURCES = mod_roster.c
+libmod_roster_la_LDFLAGS = -shared -E
+
+libmod_session_la_SOURCES = mod_session.c
+libmod_session_la_LDFLAGS = -shared -E
+
+libmod_template_roster_la_SOURCES = mod_template_roster.c
+libmod_template_roster_la_LDFLAGS = -shared -E
+
+libmod_vacation_la_SOURCES = mod_vacation.c
+libmod_vacation_la_LDFLAGS = -shared -E
+
+libmod_validate_la_SOURCES = mod_validate.c
+libmod_validate_la_LDFLAGS = -shared -E
diff -u --ignore-space-change src-cvs/sm/main.c src-plugins/sm/main.c
--- src-cvs/sm/main.c	2005-06-02 07:01:02.000000000 +0200
+++ src-plugins/sm/main.c	2005-08-08 12:52:30.000000000 +0200
@@ -21,7 +21,7 @@
 #include "sm.h"
 
 #ifdef HAVE_IDN
-#include <stringprep.h>
+  #include <stringprep.h>
 #endif
 
 /** @file sm/main.c
@@ -32,8 +32,9 @@
   */
 
 static sig_atomic_t sm_shutdown = 0;
-sig_atomic_t sm_lost_router = 0;
 static sig_atomic_t sm_logrotate = 0;
+static sm_t sm = NULL;
+static char* config_file;
 
 static void _sm_signal(int signum)
 {
@@ -43,7 +44,23 @@
 
 static void _sm_signal_hup(int signum)
 {
+    log_write(sm->log, LOG_NOTICE, "HUP handled. reloading modules...");
+
     sm_logrotate = 1;
+
+    /* reload dynamic modules */
+    config_t conf;
+    conf = config_new();
+    if (conf && config_load(conf, config_file) == 0) {
+        config_free(sm->config);
+        sm->config = conf;
+        /*_sm_config_expand(sm);*/ /* we want to reload modules only */
+    } else {
+        log_write(sm->log, LOG_WARNING, "couldn't reload config (%s)", config_file);
+        if (conf) config_free(conf);
+    }
+    mm_free(sm->mm);
+    sm->mm = mm_new(sm);
 }
 
 /** store the process id */
@@ -139,8 +156,6 @@
 }
 
 int main(int argc, char **argv) {
-    sm_t sm;
-    char *config_file;
     int optchar;
     sess_t sess;
     char id[1024];
@@ -266,21 +281,14 @@
     xhash_put(sm->xmlns, uri_ROSTER, (void *) ns_ROSTER);
     xhash_put(sm->xmlns, uri_AGENTS, (void *) ns_AGENTS);
     xhash_put(sm->xmlns, uri_DELAY, (void *) ns_DELAY);
-    xhash_put(sm->xmlns, uri_VERSION, (void *) ns_VERSION);
-    xhash_put(sm->xmlns, uri_TIME, (void *) ns_TIME);
-    xhash_put(sm->xmlns, uri_VCARD, (void *) ns_VCARD);
-    xhash_put(sm->xmlns, uri_PRIVATE, (void *) ns_PRIVATE);
     xhash_put(sm->xmlns, uri_BROWSE, (void *) ns_BROWSE);
     xhash_put(sm->xmlns, uri_EVENT, (void *) ns_EVENT);
     xhash_put(sm->xmlns, uri_GATEWAY, (void *) ns_GATEWAY);
-    xhash_put(sm->xmlns, uri_LAST, (void *) ns_LAST);
     xhash_put(sm->xmlns, uri_EXPIRE, (void *) ns_EXPIRE);
-    xhash_put(sm->xmlns, uri_PRIVACY, (void *) ns_PRIVACY);
     xhash_put(sm->xmlns, uri_SEARCH, (void *) ns_SEARCH);
     xhash_put(sm->xmlns, uri_DISCO, (void *) ns_DISCO);
     xhash_put(sm->xmlns, uri_DISCO_ITEMS, (void *) ns_DISCO_ITEMS);
     xhash_put(sm->xmlns, uri_DISCO_INFO, (void *) ns_DISCO_INFO);
-    xhash_put(sm->xmlns, uri_VACATION, (void *) ns_VACATION);
 
     /* supported features */
     sm->features = xhash_new(101);
@@ -379,15 +387,15 @@
 
     mio_free(sm->mio);
 
+    mm_free(sm->mm);
+    storage_free(sm->st);
+
     aci_unload(sm->acls);
     xhash_free(sm->acls);
     xhash_free(sm->features);
     xhash_free(sm->xmlns);
     xhash_free(sm->users);
 
-    mm_free(sm->mm);
-    storage_free(sm->st);
-
     sx_free(sm->router);
 
     sx_env_free(sm->sx_env);
diff -u --ignore-space-change src-cvs/sm/mm.c src-plugins/sm/mm.c
--- src-cvs/sm/mm.c	2005-01-19 19:29:38.000000000 +0100
+++ src-plugins/sm/mm.c	2005-08-05 18:21:08.000000000 +0200
@@ -19,6 +19,11 @@
  */
 
 #include "sm.h"
+#ifdef WIN32
+  #include <windows.h>
+#else
+  #include <dlfcn.h>
+#endif
 
 /** @file sm/mm.c
   * @brief module manager
@@ -30,82 +35,17 @@
 /* these functions implement a multiplexor to get calls to the correct module
  * for the given type */
 
-
-/* if you add a module, you'll need to update these arrays */
-
-extern int active_init(mod_instance_t);
-extern int announce_init(mod_instance_t);
-extern int deliver_init(mod_instance_t);
-extern int disco_init(mod_instance_t);
-extern int disco_publish_init(mod_instance_t);
-extern int echo_init(mod_instance_t);
-extern int help_init(mod_instance_t);
-extern int offline_init(mod_instance_t);
-extern int presence_init(mod_instance_t);
-extern int privacy_init(mod_instance_t);
-extern int roster_init(mod_instance_t);
-extern int session_init(mod_instance_t);
-extern int vacation_init(mod_instance_t);
-extern int validate_init(mod_instance_t);
-extern int iq_last_init(mod_instance_t);
-extern int iq_private_init(mod_instance_t);
-extern int iq_time_init(mod_instance_t);
-extern int iq_vcard_init(mod_instance_t);
-extern int iq_version_init(mod_instance_t);
-extern int template_roster_init(mod_instance_t);
-
-char *module_names[] = {
-    "active",
-    "announce",
-    "deliver",
-    "disco",
-    "disco-publish",
-    "echo",
-    "help",
-    "offline",
-    "presence",
-    "privacy",
-    "roster",
-    "session",
-    "vacation",
-    "validate",
-    "iq-last",
-    "iq-private",
-    "iq-time",
-    "iq-vcard",
-    "iq-version",
-    "template-roster",
-    NULL
-};
-
-module_init_fn module_inits[] = {
-    active_init,
-    announce_init,
-    deliver_init,
-    disco_init,
-    disco_publish_init,
-    echo_init,
-    help_init,
-    offline_init,
-    presence_init,
-    privacy_init,
-    roster_init,
-    session_init,
-    vacation_init,
-    validate_init,
-    iq_last_init,
-    iq_private_init,
-    iq_time_init,
-    iq_vcard_init,
-    iq_version_init,
-    template_roster_init,
-    NULL
-};
+/* Notes on dynamic modules (cedricv@) :
+   Modules are searched by name mod_[modulename].so or mod_[modulename].dll
+   depending platform.
+   You have to set <path>[full_path]</path> within <modules> in sm.xml config,
+   else it will only search in LD_LIBRARY_PATH or c:\windows\system32
+ */
 
 mm_t mm_new(sm_t sm) {
     mm_t mm;
     int celem, melem, attr, i, *nlist = NULL;
-    char id[13], name[32], arg[1024];
+    char id[13], name[32], mod_fullpath[512], arg[1024], *modules_path;
     mod_chain_t chain = (mod_chain_t) NULL;
     mod_instance_t **list = NULL, mi;
     module_t mod;
@@ -119,6 +59,12 @@
     if((celem = nad_find_elem(sm->config->nad, 0, -1, "modules", 1)) < 0)
         return mm;
 
+    modules_path = config_get_one(sm->config, "modules.path", 0);
+    if (modules_path != NULL)
+        log_write(sm->log, LOG_NOTICE, "modules search path: %s", modules_path);
+    else
+        log_write(sm->log, LOG_WARNING, "modules search path undefined !");
+
     celem = nad_find_elem(sm->config->nad, celem, -1, "chain", 1);
     while(celem >= 0) {
         if((attr = nad_find_attr(sm->config->nad, celem, -1, "id", NULL)) < 0) {
@@ -194,7 +140,7 @@
         }
 
         if(list == NULL) {
-            log_write(sm->log, LOG_ERR, "unknwon chain type '%s'", id);
+            log_write(sm->log, LOG_ERR, "unknown chain type '%s'", id);
 
             celem = nad_find_elem(sm->config->nad, celem, -1, "chain", 0);
             continue;
@@ -207,12 +153,6 @@
                 continue;
             }
 
-            snprintf(name, 32, "%.*s", NAD_CDATA_L(sm->config->nad, melem), NAD_CDATA(sm->config->nad, melem));
-
-            for(i = 0; module_names[i] != NULL; i++) {
-                if(strcmp(name, module_names[i]) == 0) {
-                    log_debug(ZONE, "adding module '%s' to chain '%s'", name, id);
-
                     arg[0] = '\0';
                     attr = nad_find_attr(sm->config->nad, melem, -1, "arg", NULL);
                     if(attr >= 0) {
@@ -220,6 +160,8 @@
                         log_debug(ZONE, "module arg: %s", arg);
                     }
 
+            snprintf(name, 32, "%.*s", NAD_CDATA_L(sm->config->nad, melem), NAD_CDATA(sm->config->nad, melem));
+
                     mod = xhash_get(mm->modules, name);
                     if(mod == NULL) {
                         mod = (module_t) malloc(sizeof(struct module_st));
@@ -228,10 +170,42 @@
                         mod->mm = mm;
                         mod->index = mm->nindex;
                         mod->name = strdup(name);
+                #ifndef WIN32
+                  if (modules_path != NULL)  FIXME:
+                      snprintf(mod_fullpath, 512, "%slibmod_%s.so", modules_path, name);
+                  else
+                      snprintf(mod_fullpath, 512, "libmod_%s.so", name);
+                  mod->handle = dlopen(mod_fullpath, RTLD_LAZY);
+                  if (mod->handle != NULL)
+                      mod->module_init_fn = dlsym(mod->handle, "module_init");
+                #else
+                  if (modules_path != NULL)
+                      snprintf(mod_fullpath, 512, "%smod_%s.dll", modules_path, name);
+                  else
+                      snprintf(mod_fullpath, 512, "mod_%s.dll", name);
+                  mod->handle = (void*) LoadLibrary(mod_fullpath);
+                  if (mod->handle != NULL)
+                      mod->module_init_fn = GetProcAddress((HMODULE) mod->handle, "module_init");
+                #endif
 
+                if (mod->handle != NULL && mod->module_init_fn != NULL) {
+                    log_debug(ZONE, "preloaded module '%s' to chain '%s' (not added yet)", name, id);
                         xhash_put(mm->modules, mod->name, (void *) mod);
-
                         mm->nindex++;
+                } else {
+                    #ifndef WIN32
+                      log_write(sm->log, LOG_ERR, "failed loading module '%s' to chain '%s' (%s)", name, id, dlerror());
+                      if (mod->handle != NULL)
+                          dlclose(mod->handle);
+                    #else
+                      log_write(sm->log, LOG_ERR, "failed loading module '%s' to chain '%s' (errcode: %x)", name, id, GetLastError());
+                      if (mod->handle != NULL)
+                          FreeLibrary((HMODULE) mod->handle);
+                    #endif
+
+                    melem = nad_find_elem(sm->config->nad, melem, -1, "module", 0);
+                    continue;
+                }
                     }
 
                     mi = (mod_instance_t) malloc(sizeof(struct mod_instance_st));
@@ -243,13 +217,21 @@
                     mi->arg = (arg[0] == '\0') ? NULL : strdup(arg);
                     mi->seq = mod->init;
 
-                    if((module_inits[i])(mi) != 0) {
-                        log_debug(ZONE, "init for module '%s' (seq %d) failed", name, mi->seq);
-
+            if(mod->module_init_fn(mi) != 0) {
+                log_write(sm->log, LOG_ERR, "init for module '%s' (seq %d) failed", name, mi->seq);
                         free(mi);
 
                         if(mod->init == 0) {
                             xhash_zap(mm->modules, mod->name);
+
+                    #ifndef WIN32
+                      if (mod->handle != NULL)
+                          dlclose(mod->handle);
+                    #else
+                      if (mod->handle != NULL)
+                          FreeLibrary((HMODULE) mod->handle);
+                    #endif
+
                             free(mod->name);
                             free(mod);
 
@@ -265,11 +247,9 @@
                     *list = (mod_instance_t *) realloc(*list, sizeof(mod_instance_t) * (*nlist + 1));
                     (*list)[*nlist] = mi;
 
-                    log_debug(ZONE, "module '%s' added to chain '%s' (order %d index %d seq %d)", mod->name, id, *nlist, mod->index, mi->seq);
+            log_write(sm->log, LOG_NOTICE, "module '%s' added to chain '%s' (order %d index %d seq %d)", mod->name, id, *nlist, mod->index, mi->seq);
 
                     (*nlist)++;
-                }
-            }
 
             melem = nad_find_elem(sm->config->nad, melem, -1, "module", 0);
         }
@@ -286,6 +266,14 @@
     if(mod->free != NULL)
         (mod->free)(mod);
 
+    #ifndef WIN32
+        if (mod->handle != NULL)
+            dlclose(mod->handle);
+    #else
+        if (mod->handle != NULL)
+            FreeLibrary((HMODULE) mod->handle);
+    #endif
+
     free(mod->name);
     free(mod);
 }
diff -u --ignore-space-change src-cvs/sm/mod_active.c src-plugins/sm/mod_active.c
--- src-cvs/sm/mod_active.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_active.c	2005-08-04 12:29:52.000000000 +0200
@@ -67,7 +67,7 @@
     storage_delete(mi->sm->st, "active", jid_user(jid), NULL);
 }
 
-int active_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_announce.c src-plugins/sm/mod_announce.c
--- src-cvs/sm/mod_announce.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_announce.c	2005-08-04 12:29:47.000000000 +0200
@@ -294,7 +294,7 @@
     free(data);
 }
 
-int announce_init(mod_instance_t mi) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
     moddata_t data;
 
diff -u --ignore-space-change src-cvs/sm/mod_deliver.c src-plugins/sm/mod_deliver.c
--- src-cvs/sm/mod_deliver.c	2003-11-30 23:02:25.000000000 +0100
+++ src-plugins/sm/mod_deliver.c	2005-08-04 14:32:32.000000000 +0200
@@ -86,8 +86,7 @@
     return mod_PASS;
 }
 
-int deliver_init(mod_instance_t mi, char *arg)
-{
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_disco.c src-plugins/sm/mod_disco.c
--- src-cvs/sm/mod_disco.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_disco.c	2005-08-04 12:46:26.000000000 +0200
@@ -611,7 +611,7 @@
     free(d);
 }
 
-int disco_init(mod_instance_t mi, char *arg)
+DLLEXPORT int module_init(mod_instance_t mi, char *arg)
 {
     module_t mod = mi->mod;
     disco_t d;
diff -u --ignore-space-change src-cvs/sm/mod_disco_publish.c src-plugins/sm/mod_disco_publish.c
--- src-cvs/sm/mod_disco_publish.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_disco_publish.c	2005-08-04 12:29:25.000000000 +0200
@@ -299,7 +299,7 @@
     storage_delete(mi->sm->st, "disco-items", jid_user(jid), NULL);
 }
 
-int disco_publish_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     if(mi->mod->init) return 0;
 
     log_debug(ZONE, "disco publish module init");
diff -u --ignore-space-change src-cvs/sm/mod_echo.c src-plugins/sm/mod_echo.c
--- src-cvs/sm/mod_echo.c	2003-11-03 02:06:48.000000000 +0100
+++ src-plugins/sm/mod_echo.c	2005-08-04 14:33:39.000000000 +0200
@@ -41,8 +41,7 @@
     return mod_HANDLED;
 }
 
-int echo_init(mod_instance_t mi, char *arg)
-{
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_help.c src-plugins/sm/mod_help.c
--- src-cvs/sm/mod_help.c	2003-11-03 02:06:48.000000000 +0100
+++ src-plugins/sm/mod_help.c	2005-08-04 14:33:49.000000000 +0200
@@ -61,8 +61,7 @@
     return mod_HANDLED;
 }
 
-int help_init(mod_instance_t mi, char *arg)
-{
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_iq_last.c src-plugins/sm/mod_iq_last.c
--- src-cvs/sm/mod_iq_last.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_iq_last.c	2005-08-08 13:58:22.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.13.2.2 $
   */
 
+#define uri_LAST    "jabber:iq:last"
+static int ns_LAST = 0;
+
 static mod_ret_t _iq_last_pkt_sm(mod_instance_t mi, pkt_t pkt) {
     module_t mod = mi->mod;
     char uptime[10];
@@ -126,7 +129,12 @@
     storage_delete(mi->sm->st, "logout", jid_user(jid), NULL);
 }
 
-int iq_last_init(mod_instance_t mi, char *arg) {
+static void _iq_last_free(module_t mod) {
+    sm_unregister_ns(mod->mm->sm, uri_LAST);
+    feature_unregister(mod->mm->sm, uri_LAST);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
@@ -135,10 +143,12 @@
     mod->pkt_user = _iq_last_pkt_user;
     mod->pkt_sm = _iq_last_pkt_sm;
     mod->user_delete = _iq_last_user_delete;
+    mod->free = _iq_last_free;
 
     /* startup time */
     mod->private = (void *) time(NULL);
 
+    ns_LAST = sm_register_ns(mod->mm->sm, uri_LAST);
     feature_register(mod->mm->sm, uri_LAST);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_iq_private.c src-plugins/sm/mod_iq_private.c
--- src-cvs/sm/mod_iq_private.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_iq_private.c	2005-08-08 13:58:51.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.18.2.4 $
   */
 
+#define uri_PRIVATE    "jabber:iq:private"
+static int ns_PRIVATE = 0;
+
 static mod_ret_t _iq_private_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {
     int ns, elem, target, targetns;
     st_ret_t ret;
@@ -168,14 +171,21 @@
     storage_delete(mi->sm->st, "private", jid_user(jid), NULL);
 }
 
-int iq_private_init(mod_instance_t mi, char *arg) {
+static void _iq_private_free(module_t mod) {
+     sm_unregister_ns(mod->mm->sm, uri_PRIVATE);
+     feature_unregister(mod->mm->sm, uri_PRIVATE);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
-    if(mod->init) return 0;
+    if (mod->init) return 0;
 
     mod->in_sess = _iq_private_in_sess;
     mod->user_delete = _iq_private_user_delete;
+    mod->free = _iq_private_free;
 
+    ns_PRIVATE = sm_register_ns(mod->mm->sm, uri_PRIVATE);
     feature_register(mod->mm->sm, uri_PRIVATE);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_iq_time.c src-plugins/sm/mod_iq_time.c
--- src-cvs/sm/mod_iq_time.c	2004-04-15 04:26:08.000000000 +0200
+++ src-plugins/sm/mod_iq_time.c	2005-08-08 13:59:58.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.9.2.1 $
   */
 
+#define uri_TIME    "jabber:iq:time"
+static int ns_TIME = 0;
+
 #ifdef HAVE_TZNAME
 extern char *tzname[];
 #endif
@@ -69,14 +72,20 @@
     return mod_HANDLED;
 }
 
-int iq_time_init(mod_instance_t mi, char *arg)
-{
+static void _iq_time_free(module_t mod) {
+     sm_unregister_ns(mod->mm->sm, uri_TIME);
+     feature_unregister(mod->mm->sm, uri_TIME);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
 
     mod->pkt_sm = _iq_time_pkt_sm;
+    mod->free = _iq_time_free;
 
+    ns_TIME = sm_register_ns(mod->mm->sm, uri_TIME);
     feature_register(mod->mm->sm, uri_TIME);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_iq_vcard.c src-plugins/sm/mod_iq_vcard.c
--- src-cvs/sm/mod_iq_vcard.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_iq_vcard.c	2005-08-08 14:00:21.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.19.2.3 $
   */
 
+#define uri_VCARD    "vcard-temp"
+static int ns_VCARD = 0;
+
 /**
  * these are the vcard attributes that gabber supports. they're also
  * all strings, and thus easy to automate. there might be more in
@@ -109,7 +112,7 @@
     log_debug(ZONE, "building packet from object");
 
     pkt = pkt_create(sm, "iq", "result", NULL, NULL);
-    nad_append_elem(pkt->nad, nad_add_namespace(pkt->nad, "vcard-temp", NULL), "vCard", 2);
+    nad_append_elem(pkt->nad, nad_add_namespace(pkt->nad, uri_VCARD, NULL), "vCard", 2);
 
     if(!os_iter_first(os))
         return pkt;
@@ -274,7 +277,12 @@
     storage_delete(mi->sm->st, "vcard", jid_user(jid), NULL);
 }
 
-int iq_vcard_init(mod_instance_t mi, char *arg) {
+static void _iq_vcard_free(module_t mod) {
+    sm_unregister_ns(mod->mm->sm, uri_VCARD);
+    feature_unregister(mod->mm->sm, uri_VCARD);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
@@ -282,8 +290,10 @@
     mod->in_sess = _iq_vcard_in_sess;
     mod->pkt_user = _iq_vcard_pkt_user;
     mod->user_delete = _iq_vcard_user_delete;
+    mod->free = _iq_vcard_free;
 
-    feature_register(mod->mm->sm, "vcard-temp");
+    ns_VCARD = sm_register_ns(mod->mm->sm, uri_VCARD);
+    feature_register(mod->mm->sm, uri_VCARD);
 
     return 0;
 }
diff -u --ignore-space-change src-cvs/sm/mod_iq_version.c src-plugins/sm/mod_iq_version.c
--- src-cvs/sm/mod_iq_version.c	2004-06-01 01:01:42.000000000 +0200
+++ src-plugins/sm/mod_iq_version.c	2005-08-08 14:00:45.000000000 +0200
@@ -31,6 +31,9 @@
 # include <sys/utsname.h>
 #endif
 
+#define uri_VERSION     "jabber:iq:version"
+static int ns_VERSION = 0;
+
 static mod_ret_t _iq_version_pkt_sm(mod_instance_t mi, pkt_t pkt) {
     char buf[256];
 
@@ -197,14 +200,20 @@
     return mod_HANDLED;
 }
 
-int iq_version_init(mod_instance_t mi, char *arg)
-{
+static void _iq_version_free(module_t mod) {
+     sm_unregister_ns(mod->mm->sm, uri_VERSION);
+     feature_unregister(mod->mm->sm, uri_VERSION);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
 
     mod->pkt_sm = _iq_version_pkt_sm;
+    mod->free = _iq_version_free;
 
+    ns_VERSION = sm_register_ns(mod->mm->sm, uri_VERSION);
     feature_register(mod->mm->sm, uri_VERSION);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_offline.c src-plugins/sm/mod_offline.c
--- src-cvs/sm/mod_offline.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_offline.c	2005-08-04 12:31:04.000000000 +0200
@@ -220,7 +220,7 @@
     storage_delete(mi->sm->st, "queue", jid_user(jid), NULL);
 }
 
-int offline_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_presence.c src-plugins/sm/mod_presence.c
--- src-cvs/sm/mod_presence.c	2004-04-02 06:34:15.000000000 +0200
+++ src-plugins/sm/mod_presence.c	2005-08-04 12:30:57.000000000 +0200
@@ -135,7 +135,7 @@
     return mod_HANDLED;
 }
 
-int presence_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_privacy.c src-plugins/sm/mod_privacy.c
--- src-cvs/sm/mod_privacy.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_privacy.c	2005-08-08 14:02:05.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.19.2.11 $
   */
 
+#define uri_PRIVACY    "jabber:iq:privacy"
+static int ns_PRIVACY = 0;
+
 typedef struct zebra_st         *zebra_t;
 typedef struct zebra_list_st    *zebra_list_t;
 typedef struct zebra_item_st    *zebra_item_t;
@@ -87,7 +90,7 @@
   zebra_list_t *z_val;
 };
 
-static void _privacy_free(zebra_t z) {
+static void _privacy_free_z(zebra_t z) {
     zebra_list_t zlist;
     union xhashv xhv;
 
@@ -106,7 +109,7 @@
 
 static void _privacy_user_free(zebra_t *z) {
     if(*z != NULL)
-        _privacy_free(*z);
+        _privacy_free_z(*z);
 }
 
 static int _privacy_user_load(mod_instance_t mi, user_t user) {
@@ -124,7 +127,7 @@
     /* free if necessary */
     z = user->module_data[mod->index];
     if(z != NULL)
-        _privacy_free(z);
+        _privacy_free_z(z);
 
     z = (zebra_t) malloc(sizeof(struct zebra_st));
     memset(z, 0, sizeof(struct zebra_st));
@@ -1032,17 +1035,24 @@
     storage_delete(mi->sm->st, "privacy-default", jid_user(jid), NULL);
 }
 
-int privacy_init(mod_instance_t mi, char *arg) {
+static void _privacy_free(module_t mod) {
+     sm_unregister_ns(mod->mm->sm, uri_PRIVACY);
+     feature_unregister(mod->mm->sm, uri_PRIVACY);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
-    if(mod->init) return 0;
+    if (mod->init) return 0;
 
     mod->user_load = _privacy_user_load;
     mod->in_router = _privacy_in_router;
     mod->out_router = _privacy_out_router;
     mod->in_sess = _privacy_in_sess;
     mod->user_delete = _privacy_user_delete;
+    mod->free = _privacy_free;
 
+    ns_PRIVACY = sm_register_ns(mod->mm->sm, uri_PRIVACY);
     feature_register(mod->mm->sm, uri_PRIVACY);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_roster.c src-plugins/sm/mod_roster.c
--- src-cvs/sm/mod_roster.c	2005-04-14 20:33:15.000000000 +0200
+++ src-plugins/sm/mod_roster.c	2005-08-05 21:27:04.000000000 +0200
@@ -618,17 +618,18 @@
                         os_object_get_bool(os, o, "from", &item->from);
                         os_object_get_int(os, o, "ask", &item->ask);
 
-                        log_debug(ZONE, "adding %s to roster (to %d from %d ask %d name %s)", jid_full(item->jid), item->to, item->from, item->ask, item->name);
-
                         olditem = xhash_get(user->roster, jid_full(item->jid));
                         if(olditem) {
-                            log_debug(ZONE, "removing old %s entry first", jid_full(item->jid));
+                            log_debug(ZONE, "removing old %s roster entry", jid_full(item->jid));
                             xhash_zap(user->roster, jid_full(item->jid));
                             _roster_free_walker(user->roster, jid_full(item->jid), (void *) olditem, NULL);
                         }
 
                         /* its good */
                         xhash_put(user->roster, jid_full(item->jid), (void *) item);
+
+                        log_debug(ZONE, "added %s to roster (to %d from %d ask %d name %s)",
+                                  jid_full(item->jid), item->to, item->from, item->ask, item->name);
                     }
                 }
             } while(os_iter_next(os));
@@ -670,7 +671,7 @@
     storage_delete(mi->sm->st, "roster-groups", jid_user(jid), NULL);
 }
 
-int roster_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/mod_session.c src-plugins/sm/mod_session.c
--- src-cvs/sm/mod_session.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_session.c	2005-08-04 12:30:47.000000000 +0200
@@ -308,7 +308,7 @@
     return mod_PASS;
 }
 
-int session_init(mod_instance_t mi, char *arg) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     if(mi->mod->init) return 0;
 
     mi->mod->in_router = _session_in_router;
diff -u --ignore-space-change src-cvs/sm/mod_template_roster.c src-plugins/sm/mod_template_roster.c
--- src-cvs/sm/mod_template_roster.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_template_roster.c	2005-08-04 12:30:40.000000000 +0200
@@ -243,7 +243,7 @@
     free(tr);
 }
 
-int template_roster_init(mod_instance_t mi, user_t user) {
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
     char *filename;
     template_roster_t tr;
diff -u --ignore-space-change src-cvs/sm/mod_vacation.c src-plugins/sm/mod_vacation.c
--- src-cvs/sm/mod_vacation.c	2005-03-23 19:01:25.000000000 +0100
+++ src-plugins/sm/mod_vacation.c	2005-08-08 14:08:37.000000000 +0200
@@ -27,6 +27,9 @@
   * $Revision: 1.7.2.2 $
   */
 
+#define uri_VACATION    "http://jabber.org/protocol/vacation"
+static int ns_VACATION = 0;
+
 typedef struct _vacation_st {
     time_t  start;
     time_t  end;
@@ -224,7 +227,12 @@
     storage_delete(mi->sm->st, "vacation-settings", jid_user(jid), NULL);
 }
 
-int vacation_init(mod_instance_t mi, char *arg) {
+static void _vacation_free(module_t mod) {
+     sm_unregister_ns(mod->mm->sm, uri_VACATION);
+     feature_unregister(mod->mm->sm, uri_VACATION);
+}
+
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
@@ -233,7 +241,9 @@
     mod->pkt_user = _vacation_pkt_user;
     mod->user_load = _vacation_user_load;
     mod->user_delete = _vacation_user_delete;
+    mod->free = _vacation_free; /* mmm good! :) */
 
+    ns_VACATION = sm_register_ns(mod->mm->sm, uri_VACATION);
     feature_register(mod->mm->sm, uri_VACATION);
 
     return 0;
diff -u --ignore-space-change src-cvs/sm/mod_validate.c src-plugins/sm/mod_validate.c
--- src-cvs/sm/mod_validate.c	2003-11-03 02:06:48.000000000 +0100
+++ src-plugins/sm/mod_validate.c	2005-08-04 14:33:16.000000000 +0200
@@ -43,8 +43,7 @@
     return _validate_in_sess(mi, NULL, pkt);
 }
 
-int validate_init(mod_instance_t mi, char *arg)
-{
+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {
     module_t mod = mi->mod;
 
     if(mod->init) return 0;
diff -u --ignore-space-change src-cvs/sm/pkt.c src-plugins/sm/pkt.c
--- src-cvs/sm/pkt.c	2004-12-22 10:14:32.000000000 +0100
+++ src-plugins/sm/pkt.c	2005-08-08 14:07:10.000000000 +0200
@@ -424,12 +424,24 @@
         jid_free(pkt->rto);
     pkt->rto = jid_new(pkt->sm->pc, sess->c2s, -1);
 
+    if(pkt->rto == NULL) {
+        log_debug(ZONE, "invalid to address on packet, unable to route");
+        pkt_free(pkt);
+        return;
+    }
+
     nad_set_attr(pkt->nad, 0, -1, "to", pkt->rto->domain, 0);
 
     if(pkt->rfrom != NULL)
         jid_free(pkt->rfrom);
     pkt->rfrom = jid_new(pkt->sm->pc, pkt->sm->id, -1);
 
+    if(pkt->rfrom == NULL) {
+        log_debug(ZONE, "invalid to address on packet, unable to route");
+        pkt_free(pkt);
+        return;
+    }
+
     nad_set_attr(pkt->nad, 0, -1, "from", pkt->rfrom->domain, 0);
 
     ret = mm_out_sess(pkt->sm->mm, sess, pkt);
diff -u --ignore-space-change src-cvs/sm/sm.c src-plugins/sm/sm.c
--- src-cvs/sm/sm.c	2005-01-07 12:46:52.000000000 +0100
+++ src-plugins/sm/sm.c	2005-08-05 15:56:25.000000000 +0200
@@ -27,6 +27,8 @@
   * $Revision: 1.41.2.5 $
   */
 
+sig_atomic_t sm_lost_router = 0;
+
 /** our master callback */
 int sm_sx_callback(sx_t s, sx_event_t e, void *data, void *arg) {
     sm_t sm = (sm_t) arg;
@@ -53,8 +55,8 @@
             /* do the read */
             len = recv(sm->fd, buf->data, buf->len, 0);
 
-            if(len < 0) {
-                if(errno == EWOULDBLOCK || errno == EINTR || errno == EAGAIN) {
+            if (len < 0) {
+                if (errno == EWOULDBLOCK || errno == EINTR || errno == EAGAIN) {
                     buf->len = 0;
                     return 0;
                 }
@@ -66,7 +68,7 @@
                 return -1;
             }
 
-            else if(len == 0) {
+            else if (len == 0) {
                 /* they went away */
                 sx_kill(s);
 
@@ -83,12 +85,12 @@
             log_debug(ZONE, "writing to %d", sm->fd);
 
             len = send(sm->fd, buf->data, buf->len, 0);
-            if(len >= 0) {
+            if (len >= 0) {
                 log_debug(ZONE, "%d bytes written", len);
                 return len;
             }
 
-            if(errno == EWOULDBLOCK || errno == EINTR || errno == EAGAIN)
+            if (errno == EWOULDBLOCK || errno == EINTR || errno == EAGAIN)
                 return 0;
 
             log_write(sm->log, LOG_NOTICE, "[%d] [router] write error: %s (%d)", sm->fd, strerror(errno), errno);
@@ -130,13 +132,15 @@
             nad = (nad_t) data;
 
             /* drop unqualified packets */
-            if(NAD_ENS(nad, 0) < 0) {
+            if (NAD_ENS(nad, 0) < 0) {
                 nad_free(nad);
                 return 0;
             }
             /* watch for the features packet */
-            if(s->state == state_STREAM) {
-                if(NAD_NURI_L(nad, NAD_ENS(nad, 0)) != strlen(uri_STREAMS) || strncmp(uri_STREAMS, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_STREAMS)) != 0 || NAD_ENAME_L(nad, 0) != 8 || strncmp("features", NAD_ENAME(nad, 0), 8) != 0) {
+            if (s->state == state_STREAM) {
+                if (NAD_NURI_L(nad, NAD_ENS(nad, 0)) != strlen(uri_STREAMS)
+                    || strncmp(uri_STREAMS, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_STREAMS)) != 0
+                    || NAD_ENAME_L(nad, 0) != 8 || strncmp("features", NAD_ENAME(nad, 0), 8) != 0) {
                     log_debug(ZONE, "got a non-features packet on an unauth'd stream, dropping");
                     nad_free(nad);
                     return 0;
@@ -144,12 +148,12 @@
 
 #ifdef HAVE_SSL
                 /* starttls if we can */
-                if(sm->sx_ssl != NULL && s->ssf == 0) {
+                if (sm->sx_ssl != NULL && s->ssf == 0) {
                     ns = nad_find_scoped_namespace(nad, uri_TLS, NULL);
-                    if(ns >= 0) {
+                    if (ns >= 0) {
                         elem = nad_find_elem(nad, 0, ns, "starttls", 1);
-                        if(elem >= 0) {
-                            if(sx_ssl_client_starttls(sm->sx_ssl, s, NULL) == 0) {
+                        if (elem >= 0) {
+                            if (sx_ssl_client_starttls(sm->sx_ssl, s, NULL) == 0) {
                                 nad_free(nad);
                                 return 0;
                             }
@@ -170,8 +174,10 @@
             }
 
             /* watch for the bind response */
-            if(s->state == state_OPEN && !sm->online) {
-                if(NAD_NURI_L(nad, NAD_ENS(nad, 0)) != strlen(uri_COMPONENT) || strncmp(uri_COMPONENT, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_COMPONENT)) != 0 || NAD_ENAME_L(nad, 0) != 4 || strncmp("bind", NAD_ENAME(nad, 0), 4)) {
+            if (s->state == state_OPEN && !sm->online) {
+                if (NAD_NURI_L(nad, NAD_ENS(nad, 0)) != strlen(uri_COMPONENT)
+                    || strncmp(uri_COMPONENT, NAD_NURI(nad, NAD_ENS(nad, 0)), strlen(uri_COMPONENT)) != 0
+                    || NAD_ENAME_L(nad, 0) != 4 || strncmp("bind", NAD_ENAME(nad, 0), 4)) {
                     log_debug(ZONE, "got a packet from router, but we're not online, dropping");
                     nad_free(nad);
                     return 0;
@@ -197,7 +203,7 @@
             log_debug(ZONE, "got a packet");
 
             pkt = pkt_new(sm, (nad_t) data);
-            if(pkt == NULL) {
+            if (pkt == NULL) {
                 log_debug(ZONE, "invalid packet, dropping");
 
                 nad_free(nad);
@@ -221,7 +227,7 @@
     sm_t sm = (sm_t) arg;
     int nbytes;
 
-    switch(a) {
+    switch (a) {
         case action_READ:
             log_debug(ZONE, "read action on fd %d", fd);
 
@@ -282,23 +288,26 @@
     sns = nad_add_namespace(nad, uri_SESSION, "sc");
     nad_append_elem(nad, sns, "session", 1);
 
-    if(dest->c2s_id[0] != '\0')
+    if (dest->c2s_id[0] != '\0')
         nad_append_attr(nad, sns, "c2s", dest->c2s_id);
-    if(dest->sm_id[0] != '\0')
+    if (dest->sm_id[0] != '\0')
         nad_append_attr(nad, sns, "sm", dest->sm_id);
 
     nad_append_attr(nad, -1, "action", action);
-    if(target != NULL)
+    if (target != NULL)
         nad_append_attr(nad, -1, "target", target);
 
-    log_debug(ZONE, "routing nad to %s from %s c2s %s s2s %s action %s target %s", dest->c2s, dest->user->sm->id, dest->c2s_id, dest->sm_id, action, target);
+    log_debug(ZONE,
+              "routing nad to %s from %s c2s %s s2s %s action %s target %s",
+              dest->c2s, dest->user->sm->id, dest->c2s_id, dest->sm_id,
+              action, target);
 
     sx_nad_write(dest->user->sm->router, nad);
 }
 
 /** this is gratuitous, but apache gets one, so why not? */
 void sm_signature(sm_t sm, char *str) {
-    if(sm->siglen == 0) {
+    if (sm->siglen == 0) {
         snprintf(&sm->signature[sm->siglen], 2048 - sm->siglen, "%s", str);
         sm->siglen += strlen(str);
     } else {
@@ -306,3 +315,27 @@
         sm->siglen += strlen(str) + 1;
     }
 }
+
+/** register a new global ns */
+int sm_register_ns(sm_t sm, char *uri) {
+    int ns_idx;
+
+    ns_idx = (int) xhash_get(sm->xmlns, uri);
+    if (ns_idx == 0) {
+        ns_idx = xhash_count(sm->xmlns) + 2;
+        xhash_put(sm->xmlns, uri, (void *) ns_idx);
+    }
+
+    return ns_idx;
+}
+
+/** unregister a global ns (never?) */
+void sm_unregister_ns(sm_t sm, char *uri) {
+    xhash_zap(sm->xmlns, uri);
+}
+
+/** get a globally registered ns */
+int sm_get_ns(sm_t sm, char *uri) {
+    return (int) xhash_get(sm->xmlns, uri);
+}
+
diff -u --ignore-space-change src-cvs/sm/sm.h src-plugins/sm/sm.h
--- src-cvs/sm/sm.h	2005-03-31 10:20:44.000000000 +0200
+++ src-plugins/sm/sm.h	2005-08-04 12:35:55.000000000 +0200
@@ -27,7 +27,7 @@
   */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+  #include <config.h>
 #endif
 
 #include "sx/sx.h"
@@ -37,10 +37,16 @@
 #include "util/util.h"
 
 #ifdef HAVE_SIGNAL_H
-# include <signal.h>
+  #include <signal.h>
 #endif
 #ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
+  #include <sys/stat.h>
+#endif
+
+#ifdef _MSC_VER
+  #define DLLEXPORT    __declspec(dllexport)
+#else
+  #define DLLEXPORT
 #endif
 
 /* forward declarations */
@@ -57,21 +63,14 @@
 #define uri_ROSTER      "jabber:iq:roster"
 #define uri_AGENTS      "jabber:iq:agents"
 #define uri_DELAY       "jabber:x:delay"
-#define uri_VERSION     "jabber:iq:version"
-#define uri_TIME        "jabber:iq:time"
-#define uri_VCARD       "vcard-temp"
-#define uri_PRIVATE     "jabber:iq:private"
 #define uri_BROWSE      "jabber:iq:browse"
 #define uri_EVENT       "jabber:x:event"
 #define uri_GATEWAY     "jabber:iq:gateway"
-#define uri_LAST        "jabber:iq:last"
 #define uri_EXPIRE      "jabber:x:expire"
-#define uri_PRIVACY     "jabber:iq:privacy"
 #define uri_SEARCH      "jabber:iq:search"
 #define uri_DISCO       "http://jabber.org/protocol/disco"
 #define uri_DISCO_ITEMS "http://jabber.org/protocol/disco#items"
 #define uri_DISCO_INFO  "http://jabber.org/protocol/disco#info"
-#define uri_VACATION    "http://jabber.org/protocol/vacation"
 
 /* indexed known namespace values */
 #define ns_AUTH         (1)
@@ -79,21 +78,14 @@
 #define ns_ROSTER       (3)
 #define ns_AGENTS       (4)
 #define ns_DELAY        (5)
-#define ns_VERSION      (6)
-#define ns_TIME         (7)
-#define ns_VCARD        (8)
-#define ns_PRIVATE      (9)
-#define ns_BROWSE       (10)
-#define ns_EVENT        (11)
-#define ns_GATEWAY      (12)
-#define ns_LAST         (13)
-#define ns_EXPIRE       (14)
-#define ns_PRIVACY      (15)
-#define ns_SEARCH       (16)
-#define ns_DISCO        (17)
-#define ns_DISCO_ITEMS  (18)
-#define ns_DISCO_INFO   (19)
-#define ns_VACATION     (20)
+#define ns_BROWSE       (6)
+#define ns_EVENT        (7)
+#define ns_GATEWAY      (8)
+#define ns_EXPIRE       (9)
+#define ns_SEARCH       (10)
+#define ns_DISCO        (11)
+#define ns_DISCO_ITEMS  (12)
+#define ns_DISCO_INFO   (13)
 
 /** packet types */
 typedef enum { 
@@ -280,6 +272,10 @@
 void            sm_c2s_action(sess_t dest, char *action, char *target);
 void            sm_signature(sm_t sm, char *str);
 
+int             sm_register_ns(sm_t sm, char *uri);
+void            sm_unregister_ns(sm_t sm, char *uri);
+int             sm_get_ns(sm_t sm, char *uri);
+
 void            dispatch(sm_t sm, pkt_t pkt);
 
 pkt_t           pkt_error(pkt_t pkt, int err);
@@ -387,6 +383,10 @@
                                          sess->module_data where the module can store its own
                                          per-user/per-session data */
 
+    void                *handle;    /**< module handle */
+
+    int                 (*module_init_fn)(mod_instance_t);    /**< module init function */
+
     int                 init;       /**< number of times the module intialiser has been called */
 
     void                *private;   /**< module private data */
@@ -462,9 +462,6 @@
 /** fire user-delete chain */
 void                    mm_user_delete(mm_t mm, jid_t jid);
 
-/** type for the module init function */
-typedef int (*module_init_fn)(mod_instance_t);
-
 
 /* object sets */
 
