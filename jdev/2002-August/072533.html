<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [JDEV] look for help about  unicode in jabber system
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jdev%40jabber.org?Subject=Re%3A%20%5BJDEV%5D%20look%20for%20help%20about%20%20unicode%20in%20jabber%20system&In-Reply-To=%3C200208181355.g7IDtKN16732%40dave2.dave.tj%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="072527.html">
   <LINK REL="Next"  HREF="072546.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[JDEV] look for help about  unicode in jabber system</H1>
    <B>Dave</B> 
    <A HREF="mailto:jdev%40jabber.org?Subject=Re%3A%20%5BJDEV%5D%20look%20for%20help%20about%20%20unicode%20in%20jabber%20system&In-Reply-To=%3C200208181355.g7IDtKN16732%40dave2.dave.tj%3E"
       TITLE="[JDEV] look for help about  unicode in jabber system">dave at dave.tj
       </A><BR>
    <I>Sun Aug 18 08:55:20 CDT 2002</I>
    <P><UL>
        <LI>Previous message: <A HREF="072527.html">[JDEV] look for help about  unicode in jabber system
</A></li>
        <LI>Next message: <A HREF="072546.html">[JDEV] look for help about  unicode in jabber system
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#72533">[ date ]</a>
              <a href="thread.html#72533">[ thread ]</a>
              <a href="subject.html#72533">[ subject ]</a>
              <a href="author.html#72533">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Making a typedef isn't &quot;extending&quot; the language ... come on.  C was
designed even before Unicode's dad (ASCII) became the de facto standard.
There's no way you can expect a built-in type to work with Unicode chars
(although you could use an int array, with an appropriate output filter).
It's worth noting, incidentally, that UTF-8 is substantially more compact
for most machine-carried text in today's world (although when China gets
with it and embraces Capitalism that may change), so using NULL as a
string terminator ain't too bad, after all, anyway.

I've never worked on an OpenVMS Alpha, so I have no clue what kind of
supercompilers they've got.  All I know is that the conventional x86
and Apple compilers I worked with didn't know the meaning of the word
&quot;optimize.&quot;  If there's anything I like about PASCAL that I felt was
missing in C, it'd have to be nested functions (which GNU CC supports,
anyway).

I guess it's useful to have strict interfaces documented (and maybe even
have the compiler warn by default when you violate them), but I hate
compilers that try to prevent you from doing what they think amounts to
shooting yourself in the foot.  (They're close cousins of Word processors
that don't let you do what they think you don't want to do.)

 - Dave


Timothy Carpenter wrote:
&gt;<i> 
</I>&gt;<i> Apologies about the &lt;NULL&gt; tag jibe - it was late and I have never forgiven
</I>&gt;<i> C for having to be extended to get around what I saw as ox-headed string
</I>&gt;<i> handling. 
</I>&gt;<i> 
</I>&gt;<i> Well, I cannot speak for other ex-PASCAL programmers, but when I used it on
</I>&gt;<i> 64-bit OpenVMS Alphas we had awareness of 64-bit processing, quad
</I>&gt;<i> pipelining, hits due to call stacks, local and remote jumps, indirection,
</I>&gt;<i> L1&amp;2 cache behaviour, register use, soft and hard page faults and compiler
</I>&gt;<i> optimisation strengths and weaknesses. The AXP compiler was red hot and took
</I>&gt;<i> care to make fast code out of PASCAL and C alike. I dug in to the assembler
</I>&gt;<i> to see how on occasion and to compare programming styles for future
</I>&gt;<i> reference.
</I>&gt;<i> 
</I>&gt;<i> So, PASCAL programmers concerned with efficiency did exist, as now do
</I>&gt;<i> reliable and robust C programmers, which I notice in abundance here, in the
</I>&gt;<i> Jabber world (and why I feel at home).
</I>&gt;<i> 
</I>&gt;<i> &lt;crosspost type=&quot;Warning&quot; list=&quot;jig&quot;&gt;
</I>&gt;<i> I see the problems of UTF-8 and binary headers as very similar - both are
</I>&gt;<i> bit-packed conditionally-sized data. Thus, if we can handle UTF-8 properly,
</I>&gt;<i> we can handle binary headers properly. It is up to awareness in design to
</I>&gt;<i> avoid placing data across obvious boundaries. I would even go to say that we
</I>&gt;<i> need to be careful of embedded devices, so assuming 64-bit registers may
</I>&gt;<i> still be optimistic at this time.
</I>&gt;<i> 
</I>&gt;<i> My admittedly crude point about PASCAL vs. C was we should seek out and use
</I>&gt;<i> systematic and 'tight' practices, e.g. interfaces, strong typing or
</I>&gt;<i> libraries.
</I>&gt;<i> &lt;/crosspost&gt;
</I>&gt;<i> 
</I>&gt;<i> Tim
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 16/08/2002 10:50 pm, &quot;Dave&quot; &lt;<A HREF="http://mail.jabber.org/mailman/listinfo/jdev">dave at dave.tj</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; C doesn't require NULL-terminated strings.  It's just that the standard
</I>&gt;<i> &gt; C string library assumes that strings end in NULL (since that method's
</I>&gt;<i> &gt; proven to be very effective for many applications).  There are plenty
</I>&gt;<i> &gt; of enumerated-string libraries for C, and because strings aren't built
</I>&gt;<i> &gt; into the language, those libraries can be every bit as efficient as
</I>&gt;<i> &gt; the standard C routines (but then again, PASCAL people don't really
</I>&gt;<i> &gt; care much about efficiency, anyway ... if they did, they wouldn't be
</I>&gt;<i> &gt; PASCAL programmers, now, would they?).  If anything, one of C's sons
</I>&gt;<i> &gt; (that bastard created by Mr. Stroustrup) makes it rediculously easy
</I>&gt;<i> &gt; to use Unicode in the full UCS-32 format (or any of the other formats,
</I>&gt;<i> &gt; for that matter), by creating a new character data type, and using the
</I>&gt;<i> &gt; should've-been-in-STL basic_string template with that new UCS32Char type.
</I>&gt;<i> &gt; If you'd prefer to avoid leaving C (a very wise choice, IMHO), you can
</I>&gt;<i> &gt; use a wchar_t array ... or you can just stick with the extraordinarily
</I>&gt;<i> &gt; simple (and very compatible) UTF-8 :-)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; As for alignment of structure elements, anything like that is guaranteed
</I>&gt;<i> &gt; to cause portability headaches.  If you really want to do it in C, you can
</I>&gt;<i> &gt; either fake it using character arrays, or use an inline assembly block.
</I>&gt;<i> &gt; Be aware that neither C nor PASCAL provides sufficient portability
</I>&gt;<i> &gt; when you try to do that kind of stuff, because that requirement by
</I>&gt;<i> &gt; definition violates any hopes of portability (which is not necessarily
</I>&gt;<i> &gt; bad, but it's worth considering nonetheless).  Also, the primary reason
</I>&gt;<i> &gt; for system-dependent alignment is efficiency.  If your 64-bit CPU has
</I>&gt;<i> &gt; to fetch two seperate 64-bit words just to get a 2-bit value, you're
</I>&gt;<i> &gt; losing lots of potential speed.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; - Dave
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Timothy Carpenter wrote:
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; I do not think CHAR to UNICODE is the answer. CHAR is 8 bit, but UTF-8 is a
</I>&gt;<i> &gt;&gt; way of sending UNICODE without breaking 'text' streams with data that looks
</I>&gt;<i> &gt;&gt; like CR, LF EOF EOLN etc etc. RCSU is also another mechanism that is very
</I>&gt;<i> &gt;&gt; intelligent use of packing, processing and compromising between ASCII and
</I>&gt;<i> &gt;&gt; full 16-bit character sets, but I cannot recall if this protects text stream
</I>&gt;<i> &gt;&gt; handlers from shocks. UTF-8 is less compact, but simpler, with no sliding
</I>&gt;<i> &gt;&gt; windows.
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; To convert is not a huge task, to my memory - just a little masking and bit
</I>&gt;<i> &gt;&gt; shuffling...shame no one uses PASCAL, as apart from not using &lt;NULL&gt; end
</I>&gt;<i> &gt;&gt; tags for strings (yeah!), you can define structures to have conditional
</I>&gt;<i> &gt;&gt; contents nailed down to the bit position, and even crossing
</I>&gt;<i> &gt;&gt; byte/word/longword boundaries. Thus the data slots in without too much math
</I>&gt;<i> &gt;&gt; nonsense all over the place.
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; Maybe this is why many C programmers quail at the thought of binary
</I>&gt;<i> &gt;&gt; bit-packed headers and say they are unmaintainable. They probably are...in
</I>&gt;<i> &gt;&gt; C. ;-)
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; Tim
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; On 17/08/2002 12:38 pm, &quot;&#213;&#197; &#198;&#233;&quot; &lt;<A HREF="http://mail.jabber.org/mailman/listinfo/jdev">jabberjaist at hotmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; do the jabber system support to east aisa GLYPH images,chinese ,japanese
</I>&gt;<i> &gt;&gt;&gt; and korea.I want
</I>&gt;<i> &gt;&gt;&gt; my jabber server support to unicode of east aisa.but I get a trouble. my
</I>&gt;<i> &gt;&gt;&gt; friend tell me.
</I>&gt;<i> &gt;&gt;&gt; just below ,is it right ,or have a better way to resolve the problem.
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1Jabber uses UTF-8 encoding
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1We have not been facing any problems because we have been operating in
</I>&gt;<i> &gt;&gt;&gt; the
</I>&gt;<i> &gt;&gt;&gt; ASCII domain which is a subset of UTF-8.
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1We need to find some kind of encoding algorithm/API which converts
</I>&gt;<i> &gt;&gt;&gt; Unicode
</I>&gt;<i> &gt;&gt;&gt; to UTF-8 before we send out strings to the server and some kind of decoding
</I>&gt;<i> &gt;&gt;&gt; Algorithm/API which does the opposite when we receive strings.
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1We need some kind of rendering mechanism has to make the mapping from
</I>&gt;<i> &gt;&gt;&gt; unicode to the actual character.
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1There are a couple of Microsoft APIs called MultiByteToWideChar and
</I>&gt;<i> &gt;&gt;&gt; CharToMultiByte
</I>&gt;<i> &gt;&gt;&gt; &#129;6&#166;1There is an Mlang API of Microsoft which has functions like
</I>&gt;<i> &gt;&gt;&gt; ConvertStringToUnicode and ConvertUnicodeToString (I think this is our best
</I>&gt;<i> &gt;&gt;&gt; bet. If we read this thoroughly we might be able to solve the problem)
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; 
</I>&gt;<i> &gt;&gt;&gt; _______________________________________________
</I>&gt;<i> &gt;&gt;&gt; jdev mailing list
</I>&gt;<i> &gt;&gt;&gt; <A HREF="http://mail.jabber.org/mailman/listinfo/jdev">jdev at jabber.org</A>
</I>&gt;<i> &gt;&gt;&gt; <A HREF="http://mailman.jabber.org/listinfo/jdev">http://mailman.jabber.org/listinfo/jdev</A>
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt;&gt; __________________________________________________
</I>&gt;<i> &gt;&gt; Do You Yahoo!?
</I>&gt;<i> &gt;&gt; Everything you'll ever need on one web page
</I>&gt;<i> &gt;&gt; from News and Sport to Email and Music Charts
</I>&gt;<i> &gt;&gt; <A HREF="http://uk.my.yahoo.com">http://uk.my.yahoo.com</A>
</I>&gt;<i> &gt;&gt; _______________________________________________
</I>&gt;<i> &gt;&gt; jdev mailing list
</I>&gt;<i> &gt;&gt; <A HREF="http://mail.jabber.org/mailman/listinfo/jdev">jdev at jabber.org</A>
</I>&gt;<i> &gt;&gt; <A HREF="http://mailman.jabber.org/listinfo/jdev">http://mailman.jabber.org/listinfo/jdev</A>
</I>&gt;<i> &gt;&gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; jdev mailing list
</I>&gt;<i> &gt; <A HREF="http://mail.jabber.org/mailman/listinfo/jdev">jdev at jabber.org</A>
</I>&gt;<i> &gt; <A HREF="http://mailman.jabber.org/listinfo/jdev">http://mailman.jabber.org/listinfo/jdev</A>
</I>&gt;<i> 
</I>&gt;<i> __________________________________________________
</I>&gt;<i> Do You Yahoo!?
</I>&gt;<i> Everything you'll ever need on one web page
</I>&gt;<i> from News and Sport to Email and Music Charts
</I>&gt;<i> <A HREF="http://uk.my.yahoo.com">http://uk.my.yahoo.com</A>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> jdev mailing list
</I>&gt;<i> <A HREF="http://mail.jabber.org/mailman/listinfo/jdev">jdev at jabber.org</A>
</I>&gt;<i> <A HREF="http://mailman.jabber.org/listinfo/jdev">http://mailman.jabber.org/listinfo/jdev</A>
</I>&gt;<i> 
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="072527.html">[JDEV] look for help about  unicode in jabber system
</A></li>
	<LI>Next message: <A HREF="072546.html">[JDEV] look for help about  unicode in jabber system
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#72533">[ date ]</a>
              <a href="thread.html#72533">[ thread ]</a>
              <a href="subject.html#72533">[ subject ]</a>
              <a href="author.html#72533">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://mail.jabber.org/mailman/listinfo/jdev">More information about the JDev
mailing list</a><br>
</body></html>
